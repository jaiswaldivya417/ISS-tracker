# -*- coding: utf-8 -*-
"""ProjectISA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TmsAZv9mJaKSU11YmXAdpS81mJp7ftP7
"""

import requests
import numpy
import matplotlib
import ipywidgets
!pip install skyfield

"""# Task 1"""

import skyfield

from datetime import datetime, timedelta

def fetch_iss_tle():
    tle_url = "https://celestrak.org/NORAD/elements/stations.txt"

    try:
        # Make a GET request to the TLE endpoint
        response = requests.get(tle_url)
        response.raise_for_status()  # Raise an error for bad status codes

        lines = response.text.strip().splitlines()

        # Parse the response to find the ISS entry
        for i in range(len(lines)):
            if "ISS (ZARYA)" in lines[i]:
                name = lines[i].strip()
                line1 = lines[i + 1].strip()
                line2 = lines[i + 2].strip()

                # Extract the epoch year and day from Line 1
                epoch_raw = line1[18:32].strip()
                epoch_year = int("20" + epoch_raw[:2])  # TLE format gives last 2 digits of year
                epoch_day = float(epoch_raw[2:])

                # Convert epoch to datetime
                epoch_datetime = datetime(epoch_year, 1, 1) + timedelta(days=epoch_day - 1)

                # Compare with current UTC time
                now = datetime.utcnow()
                time_diff = abs((now - epoch_datetime).total_seconds())

                # Allow ~24-hour window
                if time_diff <= 86400:
                    print("Successfully fetched recent TLE for ISS:")
                    print(name)
                    print(line1)
                    print(line2)
                    return
                else:
                    print("TLE data is outdated. Epoch:", epoch_datetime, "UTC Now:", now)
                    return

        print("ISS (ZARYA) TLE not found in the response.")

    except requests.exceptions.RequestException as e:
        print("HTTP Request failed:", e)
    except IndexError:
        print("TLE format error: Missing lines.")
    except Exception as e:
        print("Unexpected error:", e)

# Run the function
fetch_iss_tle()

from skyfield.api import load, EarthSatellite, wgs84, Topos, utc
from datetime import datetime, timedelta
import pytz
import requests
import numpy as np # Import numpy for array handling

def get_tle_for_iss():
    url = "https://celestrak.org/NORAD/elements/stations.txt"
    try:
        response = requests.get(url)
        response.raise_for_status()
        lines = response.text.strip().splitlines()
        for i, line in enumerate(lines):
            if "ISS (ZARYA)" in line:
                return lines[i].strip(), lines[i+1].strip(), lines[i+2].strip()
        raise ValueError("ISS TLE not found.")
    except Exception as e:
        print("Failed to fetch TLE data:", e)
        exit()

def get_user_coordinates():
    try:
        lat = float(input("Enter your latitude (decimal degrees, -90 to 90): "))
        lon = float(input("Enter your longitude (decimal degrees, -180 to 180): "))
        if not (-90 <= lat <= 90 and -180 <= lon <= 180):
            raise ValueError("Invalid coordinates.")
        return lat, lon
    except ValueError:
        print("Invalid input. Please enter numbers within the valid range.")
        exit()

def find_next_pass(lat, lon, tle_lines):
    from skyfield.api import utc  # Ensure this is imported

    ts = load.timescale()
    name, line1, line2 = tle_lines
    satellite = EarthSatellite(line1, line2, name, ts)

    location = wgs84.latlon(lat, lon)

    t0 = ts.now()
    t1 = ts.utc((datetime.utcnow() + timedelta(days=1)).replace(tzinfo=utc))

    # Get all pass events (0 = rise, 1 = max, 2 = set)
    times, events = satellite.find_events(location, t0, t1, altitude_degrees=10.0)

    times = list(times)
    events = list(events)

    # Group events into full passes
    pass_events = []
    current_pass = {}

    for t, e in zip(times, events):
        if e == 0:
            current_pass = {"rise": t}
        elif e == 1 and "rise" in current_pass:
            current_pass["max"] = t
        elif e == 2 and "max" in current_pass:
            current_pass["set"] = t
            pass_events.append(current_pass)
            current_pass = {}

    if not pass_events:
        print("‚ùå Could not compute a full pass event within the next 24 hours.")
        return

    # Use the first full pass
    first_pass = pass_events[0]
    rise_time = first_pass["rise"]
    max_time = first_pass["max"]
    set_time = first_pass["set"]

    local_tz = pytz.timezone('Asia/Kolkata')
    rise_dt = rise_time.utc_datetime().replace(tzinfo=pytz.utc).astimezone(local_tz)
    max_dt = max_time.utc_datetime().replace(tzinfo=pytz.utc).astimezone(local_tz)
    set_dt = set_time.utc_datetime().replace(tzinfo=pytz.utc).astimezone(local_tz)

    duration = (set_dt - rise_dt).seconds
    alt, az, _ = (satellite - location).at(max_time).altaz()

    print("\n--- ‚úÖ Next ISS Pass Details ---")
    print(f"üìç Location       : Lat {lat}, Lon {lon}")
    print(f"üîº Rise Time      : {rise_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
    print(f"üåü Peak Time      : {max_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
    print(f"üîΩ Set Time       : {set_dt.strftime('%Y-%m-%d %H:%M:%S %Z')}")
    print(f"‚è±Ô∏è Duration       : {duration} seconds")
    print(f"üìè Peak Altitude  : {alt.degrees:.2f}¬∞")

def main():
    print("üåç ISS Pass Time Calculator")
    lat, lon = get_user_coordinates()
    tle_data = get_tle_for_iss()
    find_next_pass(lat, lon, tle_data)

if __name__ == "__main__":
    main()

from google.colab import drive
drive.mount('/content/drive')

!pip install cartopy

import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from skyfield.api import load, EarthSatellite, wgs84, utc
from datetime import datetime, timedelta
import requests

# --- STEP 1: Fetch ISS TLE Data ---
def fetch_iss_tle():
    url = "https://celestrak.org/NORAD/elements/stations.txt"
    response = requests.get(url)
    response.raise_for_status()
    lines = response.text.strip().splitlines()
    for i, line in enumerate(lines):
        if "ISS (ZARYA)" in line:
            return lines[i].strip(), lines[i+1].strip(), lines[i+2].strip()
    raise RuntimeError("ISS TLE not found.")

# --- STEP 2: Compute Subpoint Over Time ---
def compute_iss_positions(satellite, ts):
    now = datetime.utcnow().replace(tzinfo=utc)
    # Convert generator to a list of datetimes
    datetimes = [now + timedelta(minutes=i) for i in range(91)]
    times = ts.utc(datetimes)  # 90-minute range

    latitudes = []
    longitudes = []

    for t in times:
        subpoint = satellite.at(t).subpoint()
        latitudes.append(subpoint.latitude.degrees)
        longitudes.append(subpoint.longitude.degrees)

    return times, latitudes, longitudes

# --- STEP 3: Plotting on Cartopy World Map ---
def plot_ground_track(times, lats, lons, satellite, ts):
    fig = plt.figure(figsize=(12, 6))
    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.stock_img()
    ax.add_feature(cfeature.BORDERS, linestyle=':')
    ax.coastlines()
    ax.gridlines(draw_labels=True, linestyle='--')

    # Plot ISS track
    ax.plot(lons, lats, color='dodgerblue', label='ISS Ground Track', linewidth=2)

    # Mark current position
    current_time = times[0]
    current_subpoint = satellite.at(current_time).subpoint()
    ax.scatter(current_subpoint.longitude.degrees,
               current_subpoint.latitude.degrees,
               color='red', s=50, label='Current Position', zorder=5)

    # Title and legend
    title_time = current_time.utc_datetime().strftime('%Y-%m-%d %H:%M:%S UTC')
    ax.set_title(f'ISS Ground Track (Next 90 Minutes)\nStart Time: {title_time}', fontsize=14)
    ax.legend(loc='lower left')

    plt.tight_layout()
    plt.show()

# --- MAIN PROGRAM ---
def main():
    print("üõ∞Ô∏è  Plotting ISS Ground Track for the Next 90 Minutes...")

    # Load TLE
    name, line1, line2 = fetch_iss_tle()
    ts = load.timescale()
    satellite = EarthSatellite(line1, line2, name, ts)

    # Compute positions
    times, lats, lons = compute_iss_positions(satellite, ts)

    # Plot
    plot_ground_track(times, lats, lons, satellite, ts)

if __name__ == "__main__":
    main()

"""# Task 2"""

!pip install skyfield
import csv
from datetime import datetime, timedelta
import pytz
import requests
from skyfield.api import load, EarthSatellite, wgs84, utc

# --- Load ISS TLE ---
def fetch_iss_tle():
    url = "https://celestrak.org/NORAD/elements/stations.txt"
    try:
        response = requests.get(url)
        response.raise_for_status()
        lines = response.text.strip().splitlines()
        for i, line in enumerate(lines):
            if "ISS (ZARYA)" in line:
                return lines[i], lines[i + 1], lines[i + 2]
    except Exception as e:
        print("Failed to fetch TLE data:", e)
        # Returning None or raising a more specific error might be better
        # depending on how the caller handles it. For now, exit as in original code.
        exit()
    raise RuntimeError("ISS TLE not found.")


# --- Find next full pass for a given location ---
def find_next_pass(lat, lon, satellite, ts):
    location = wgs84.latlon(lat, lon)
    t0 = ts.now()
    t1 = ts.utc((datetime.utcnow() + timedelta(days=1)).replace(tzinfo=utc))

    times, events = satellite.find_events(location, t0, t1, altitude_degrees=10.0)
    times = list(times)
    events = list(events)

    current_pass = {}
    for t, e in zip(times, events):
        if e == 0:
            current_pass = {"rise": t}
        elif e == 1 and "rise" in current_pass:
            current_pass["max"] = t
        elif e == 2 and "max" in current_pass:
            current_pass["set"] = t
            return current_pass  # Return only the first full pass
    return None

# --- Load city list from CSV ---
def load_locations(file_path):
    locations = []
    with open(file_path, newline='', encoding='utf-8-sig') as csvfile:
        reader = csv.DictReader(csvfile)
        # Print the fieldnames (column headers) to help diagnose the KeyError
        print("CSV Fieldnames:", reader.fieldnames)
        for row in reader:
            # Assuming the correct headers are "Location", "Latitude", "Longitude"
            # If the KeyError persists, check the output of reader.fieldnames
            # and update the keys below to match the actual headers in your CSV file.
            locations.append({
                "name": row["Location"],
                "lat": float(row["Latitude"]),
                "lon": float(row["Longitude"])
            })
    return locations

# --- Convert UTC to local time ---
def to_local(utc_time, timezone='Asia/Kolkata'):
    return utc_time.utc_datetime().replace(tzinfo=pytz.utc).astimezone(pytz.timezone(timezone))

# --- Main program ---
def main():
    ts = load.timescale()
    try:
        name, line1, line2 = fetch_iss_tle()
        satellite = EarthSatellite(line1, line2, name, ts)
    except Exception as e:
        print(f"Error fetching TLE data: {e}")
        return


    try:
        locations = load_locations("/content/locations.csv")
    except FileNotFoundError:
        print("Error: locations.csv not found. Please upload the file to /content/.")
        return
    except KeyError as e:
        print(f"Error loading locations: Missing expected column {e}. Please check the CSV headers.")
        return
    except ValueError as e:
        print(f"Error loading locations: Invalid data format in CSV - {e}. Ensure latitude and longitude are numbers.")
        return


    results = []
    print("\nüåç ISS Next Pass Predictions:\n")
    print("{:<15} {:<20} {:<20} {:<20} {:<10}".format("Location", "Rise Time", "Culmination", "Set Time", "Duration"))

    for loc in locations:
        pass_data = find_next_pass(loc["lat"], loc["lon"], satellite, ts)
        if pass_data:
            rise = to_local(pass_data["rise"])
            max_ = to_local(pass_data["max"])
            set_ = to_local(pass_data["set"])
            duration = (set_ - rise).seconds
            results.append({
                "Location": loc["name"],
                "Rise Time": rise.strftime('%Y-%m-%d %H:%M:%S'),
                "Culmination": max_.strftime('%Y-%m-%d %H:%M:%S'),
                "Set Time": set_.strftime('%Y-%m-%d %H:%M:%S'),
                "Duration": duration
            })
            print(f"{loc['name']:<15} {rise:%Y-%m-%d %H:%M:%S}   {max_:%Y-%m-%d %H:%M:%S}   {set_:%Y-%m-%d %H:%M:%S}   {duration:<10}")
        else:
            print(f"{loc['name']:<15} No visible pass found in 24 hrs.")

    # Save to CSV
    try:
        with open("iss_pass_predictions.csv", "w", newline="") as csvfile:
            fieldnames = ["Location", "Rise Time", "Culmination", "Set Time", "Duration"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in results:
                writer.writerow(row)
        print("\n‚úÖ Results saved to 'iss_pass_predictions.csv'.")
    except IOError as e:
        print(f"Error saving results to CSV: {e}")


if __name__ == "__main__":
    main()

!pip install ipywidgets

"""# Task 3"""

# --- Imports ---
import pandas as pd
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output
from datetime import datetime, timedelta
import pytz
import requests
from skyfield.api import load, EarthSatellite, wgs84, utc

# --- Load Locations from CSV ---
def load_locations(path="locations.csv"):
    return pd.read_csv(path, encoding='utf-8-sig')

locations_df = load_locations()
location_names = locations_df['Location'].tolist()

# --- Fetch TLE ---
def fetch_iss_tle():
    url = "https://celestrak.org/NORAD/elements/stations.txt"
    response = requests.get(url)
    lines = response.text.strip().splitlines()
    for i, line in enumerate(lines):
        if "ISS (ZARYA)" in line:
            return lines[i], lines[i + 1], lines[i + 2]
    raise RuntimeError("ISS TLE not found.")

# --- Predict next ISS pass ---
def find_next_pass(lat, lon, duration_minutes, satellite, ts):
    location = wgs84.latlon(lat, lon)

    for window in [duration_minutes, duration_minutes + 60, duration_minutes + 120]:
        t0 = ts.now()
        t1 = ts.utc((datetime.utcnow() + timedelta(minutes=window)).replace(tzinfo=utc))
        times, events = satellite.find_events(location, t0, t1, altitude_degrees=10.0)
        times = list(times)
        events = list(events)

        current_pass = {}
        for t, e in zip(times, events):
            if e == 0:
                current_pass = {"rise": t}
            elif e == 1 and "rise" in current_pass:
                current_pass["max"] = t
            elif e == 2 and "max" in current_pass:
                current_pass["set"] = t
                return current_pass
    return None


# --- Local time formatting ---
def to_local(utc_time, timezone='Asia/Kolkata'):
    return utc_time.utc_datetime().replace(tzinfo=pytz.utc).astimezone(pytz.timezone(timezone))

# --- Plot ---
def plot_pass(location_name, lat, lon, duration, satellite, ts):
    clear_output(wait=True)

    result = find_next_pass(lat, lon, duration, satellite, ts)

    if not result:
        print(f"No visible ISS pass in next {duration} minutes for {location_name}.")
        return

    rise = to_local(result["rise"])
    max_ = to_local(result["max"])
    set_ = to_local(result["set"])
    duration_sec = (set_ - rise).seconds
    alt, _, _ = (satellite - wgs84.latlon(lat, lon)).at(result["max"]).altaz()

    print(f"\nüìç **{location_name}** ‚Äî Next ISS Pass")
    print(f"üîº Rise Time     : {rise.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üåü Peak Time     : {max_.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üîΩ Set Time      : {set_.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"‚è±Ô∏è Duration       : {duration_sec} sec")
    print(f"üìè Peak Altitude : {alt.degrees:.2f}¬∞")

    # Optional: plot a static line showing timing
    times = [rise, max_, set_]
    labels = ["Rise", "Max", "Set"]
    y = [10, alt.degrees, 10]

    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(times, y, marker='o')
    ax.set_title(f"ISS Altitude Curve ‚Äî {location_name}")
    ax.set_ylabel("Altitude (¬∞)")
    ax.grid(True)
    for i, txt in enumerate(labels):
        ax.annotate(txt, (times[i], y[i]))
    plt.show()

# --- Interactive Widgets ---
location_dropdown = widgets.Dropdown(
    options=location_names,
    description="Location:"
)

duration_slider = widgets.IntSlider(
    value=90,
    min=10,
    max=180,
    step=10,
    description="Minutes Ahead:"
)

submit_button = widgets.Button(
    description="Predict ISS Pass",
    button_style='success'
)

# --- Load TLE and Timescale once ---
ts = load.timescale()
tle_name, tle1, tle2 = fetch_iss_tle()
satellite = EarthSatellite(tle1, tle2, tle_name, ts)

# --- Callback ---
def on_button_click(b):
    loc_name = location_dropdown.value
    row = locations_df[locations_df['Location'] == loc_name].iloc[0]
    lat, lon = row['Latitude'], row['Longitude']
    duration = duration_slider.value
    plot_pass(loc_name, lat, lon, duration, satellite, ts)

submit_button.on_click(on_button_click)

# --- Display Interface ---
display(widgets.VBox([
    location_dropdown,
    duration_slider,
    submit_button
]))

"""# Task 4"""

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from datetime import datetime, timedelta
import requests
from skyfield.api import load, EarthSatellite, wgs84, utc

# --- Fetch ISS TLE ---
def fetch_iss_tle():
    url = "https://celestrak.org/NORAD/elements/stations.txt"
    response = requests.get(url)
    lines = response.text.strip().splitlines()
    for i, line in enumerate(lines):
        if "ISS (ZARYA)" in line:
            return lines[i], lines[i+1], lines[i+2]
    raise RuntimeError("ISS TLE not found.")

# --- Compute ISS subpoints ---
def get_iss_positions():
    ts = load.timescale()
    tle_name, tle1, tle2 = fetch_iss_tle()
    satellite = EarthSatellite(tle1, tle2, tle_name, ts)

    now = datetime.utcnow().replace(tzinfo=utc)
    # Create a list of datetime objects from the generator
    datetimes = [now + timedelta(minutes=i) for i in range(91)]
    times = ts.utc(datetimes)

    lats, lons = [], []
    for t in times:
        subpoint = satellite.at(t).subpoint()
        lats.append(subpoint.latitude.degrees)
        lons.append(subpoint.longitude.degrees)

    # Normalize longitudes
    lons = [(lon + 180) % 360 - 180 for lon in lons]
    return lats, lons

# --- Animate ---
def animate_iss(latitudes, longitudes):
    fig = plt.figure(figsize=(12, 6))
    ax = plt.axes(projection=ccrs.PlateCarree())
    ax.set_global()
    ax.stock_img()
    ax.add_feature(cfeature.BORDERS)
    ax.coastlines()
    ax.gridlines(draw_labels=True, linestyle="--")

    iss_dot, = ax.plot([], [], 'ro', markersize=6, transform=ccrs.PlateCarree(), label='ISS')
    path_line, = ax.plot([], [], 'dodgerblue', linewidth=1.5, transform=ccrs.PlateCarree(), label='Track')

    plt.legend(loc='lower left')
    plt.title('üåç ISS Ground Track (Next 90 Minutes)')

    def init():
        iss_dot.set_data([], [])
        path_line.set_data([], [])
        return iss_dot, path_line

    def update(frame):
        iss_dot.set_data(longitudes[frame], latitudes[frame])
        path_line.set_data(longitudes[:frame+1], latitudes[:frame+1])
        return iss_dot, path_line

    ani = FuncAnimation(fig, update, frames=len(latitudes),
                        init_func=init, interval=200, blit=True, repeat=False)

    plt.show()

# --- Run ---
def main():
    print("üõ∞Ô∏è Animating ISS Path...")
    lats, lons = get_iss_positions()
    animate_iss(lats, lons)

main()

!pip install astroquery

"""# Task 5"""

import requests

url = "https://celestrak.org/NORAD/elements/stations.txt"
response = requests.get(url)

if response.status_code == 200:
    tle_lines = response.text.strip().split('\n')
    print("Satellite Name:", tle_lines[0])
    print("TLE Line 1:", tle_lines[1])
    print("TLE Line 2:", tle_lines[2])
else:
    print("Error downloading TLE:", response.status_code)

"""# Task 6"""

from skyfield.api import EarthSatellite, load

# Assume you already have tle_lines[1] and tle_lines[2]
satellite = EarthSatellite(tle_lines[1], tle_lines[2], tle_lines[0])
ts = load.timescale()
t = ts.now()
geocentric = satellite.at(t)
print("ISS position (km):", geocentric.position.km)

"""# Task 7"""

import requests
from datetime import datetime
from skyfield.api import load, EarthSatellite
import matplotlib.pyplot as plt

# Step 1: Fetch latest TLE data from Celestrak
url = "https://celestrak.org/NORAD/elements/stations.txt"
response = requests.get(url)

if response.status_code == 200:
    tle_lines = response.text.strip().split('\n')
    if len(tle_lines) >= 3:
        name = tle_lines[0].strip()
        line1 = tle_lines[1].strip()
        line2 = tle_lines[2].strip()
    else:
        raise ValueError("Malformed TLE response")
else:
    raise ConnectionError(f"Error downloading TLE: {response.status_code}")

# Step 2: Parse using Skyfield
ts = load.timescale()
satellite = EarthSatellite(line1, line2, name, ts)
orb = satellite.model

# Step 3: Compute orbital elements
inclination_deg = orb.inclo * (180 / 3.1415926)   # Radians to degrees
eccentricity = orb.ecco
orbital_period_min = 1440.0 / orb.no_kozai        # Period = 1 / revs per day

# Step 4: Display results
print("\nüõ∞Ô∏è ISS Orbital Elements (from latest TLE):")
print(f"Satellite Name     : {name}")
print(f"Inclination (deg)  : {inclination_deg:.3f}")
print(f"Eccentricity       : {eccentricity:.7f}")
print(f"Orbital Period (min): {orbital_period_min:.2f}")

# Step 5: Optional single-point plot (text visualization)
plt.figure(figsize=(6, 4))
plt.bar(['Inclination (¬∞)', 'Eccentricity', 'Period (min)'],
        [inclination_deg, eccentricity * 100, orbital_period_min],
        color=['skyblue', 'green', 'orange'])

plt.title(f'ISS Orbital Elements - {datetime.utcnow().date()}')
plt.ylabel('Value')
plt.grid(True, axis='y', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()